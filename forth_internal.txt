


New Plan!

run_word needs to be a bytecode interpreter. Just simple enough to execute calls to function tokens, jumps back and forth, etc.
The plan to put constants into anonymous words is scuttled a bit by the concept of compiling working on the top word in the dictionary, as those anonymous words become the new "top words".
One solution is to have a top_word pointer that refers to the word being compiled. Another is to build in such constant finding into the bytecode.




- fith -

Named dictionaries for namespaces - regular words still work as expected, but words with dots get called like "namespace address wordcall", so a word "dood" gets called in the main dictionary while "peep.dood" gets called under peep
Or maybe "peep. dood", where namespace dot words read ahead to the next method and call it with a different tick
So "peep. dood" would be "address of peep dictionary on stack, call tick, call special execute that pulls token and dictionary token"

Cell typing - cells hold a type and data, for instance "integer 2" or "float 43.1" or "character b". Words can pull the type of the word on the stack and behave accordingly.

Objects - 

definition uses a special colon word, followed by a constructor
when the word is called it reserves a new entry in the dict for it, like other variables, and runs the words provided

:obj car  float fuel  integer passengers  ;obj

methods are added later, allowing modification of the object on the fly. objects get their own namespaces
a method call puts the address of the called object on the context stack, which can be pulled by the word self.
or not? maybe a custom area...

: car.fill 100 self car. fuel




namespace

s" ls -lh" ::System exec

* puts string on stack
* ::System puts the address of the System dictionary on the stack, then runs a tick...
* exec is the function call to make within that dictionary, which is gobbled up by ::System
* ::System runs an NamespaceExecute that gobbles the exe token and the dictionary pointer

object references

->porsche fill 
--or--
porsche ->car fill

either words are typed (python style) or they are not typed (c style)
typed words know their parent object, i.e. they are smarter than a simple datastore
when created they add an additional word, ->name, that acts like a namespace call on that object
otherwise you could do it forth style, where the object just puts its pointer on the stack
then ->name calls would just be like namespace calls, but distinguished for some reason that i'd like to defend stronger than "just because"
might be part of pointer enforcement - ::name calls don't expect anything special on the stack, but ->name calls expect the object reference up top
when its execute call exits, it wants to clean that pointer up, thus it is mandatory to have

actually while that idea is clever and might actually work as a way to implement objects in ansi forth, the former is better:
* objects need to be type-aware anyway to make the cell stack and operator overloading work
* fith is supposed to be better than forth, and avoid these kinds of pains
